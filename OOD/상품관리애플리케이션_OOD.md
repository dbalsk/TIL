# **상품 관리 애플리케이션**
**[데이터베이스로 관리되는 상품관리애플리케이션](https://github.com/dbalsk/TIL/blob/main/DataBase/%EC%83%81%ED%92%88%EA%B4%80%EB%A6%AC%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98_DB.md)** 에 **객체지향적 설계 추가** 및 **리팩토링**을 하여 프로젝트 완성
  
## 추상화
>클래스를 추상화함으로써 유연성을 높이는 설계로 개선해보자. 

**✔ 애플리케이션 실행환경**   
기존의 상품관리애플리케이션은 실행환경에 따라 SimpleProductService(서비스 클래스)에 서로 다른 빈이 주입되어야 하는 상황

- 테스트 환경 (로컬 개발환경) -> **ListProductRepository** 빈 주입 (리스트 기반 리포지토리 클래스)
- 서비스 환경 -> **DatabaseProductRepository** 빈 주입 (데이터베이스 기반 리포지토리 클래스)

**✔ 인터페이스에 의존 (추상화)**   
인터페이스에 의존하도록 구현함으로써 실행환경에 따라 동작을 정의하도록 구현 

- 인터페이스 생성: 두 리포지토리 클래스의 인터페이스로 **ProductRepository** 생성 

- 인터페이스 위치: **도메인 계층**  
-> 두 리포지토리 클래스가 위치하는 **인프라스트럭처 계층**에 위치할 경우 **도메인 주도 설계의 의존성 방향에 위배**됨. (다른 모든 계층은 인프라스트럭처 계층에 의존하면 안됨)

- 의존성 방향: **인터페이스(추상적 존재)로 의존성 방향**이 모임. 
    - **서비스 클래스**: 인터페이스를 사용하기에 인터페이스에 의존
    - **리포지토리 클래스**: 인터페이스를 구현하기에 인터페이스에 의존  

- 인터페이스의 효과: 구체적인 존재가 아닌 **추상적인 존재에 의존**함으로써 애플리케이션의 **동작을 코드 변경 없이 실행 시점**에 결정 

**✔ 문제 해결**
- 문제1: 인터페이스에 두 클래스의 빈 중, 어떤 것을 넣을지 판단 불가 
    - 해결방법: **Spring Profiles** 사용 (테스트/서비스 환경에 따라 다르게 적용할 수 있도록)
        - 각 구현체에 **@Profile 추가**    
        ```@Profile("test"), @Profile("prod")```   
        - **application.properties** 파일에서 어떤 Profile로 실행할지 지정    
        ```spring.profiles.active=test```  
        - 명령어로 Profile 명시할 경우 그에 따라 실행 (명령어로 지정하지 않는 경우 위 파일에 따라 실행)  

- 문제2: 테스트 환경에서 실행 불가   
  (jdbc 의존성에서 **데이터베이스 연결 관련 자동설정**을 진행하기에 데이터베이스를 사용하지 않는 경우 실행 불가)
    - 해결방법: **properties 파일 나누기**
      >[-**Profile**]에 따라 스프링 부트에서 사용될 설정파일을 자동으로 매핑해줌.
        - **application.properties** -> 기본 Profile로 test를 지정    
            (기본값은 test로 설정하는 것이 좋음. 프로젝트 다운로드할 경우 데이터베이스없이 바로 실행 가능하도록)
        - **application-test.properties** -> 데이터베이스 연결 자동설정 제외   
        - **application-prod.properties** -> 데이터베이스 연결정보
        - ApplicationRunner에 @Profile("prod") 추가

## 의존성 주입 / 의존성 역전 원칙 
> 추상화를 통해 구체적인 구현이 아닌 인터페이스에 의존하도록 설계했다.
이를 통해 적용할 수 있었던 **의존성 주입**과 **의존성 역전 원칙**에 대해 살펴보자.

**✔ 의존성 주입 (DI-Dependency Injection)**   
객체 간의 의존 관계를 외부에서 주입하는 설계 패턴 (의존성 주입 패턴)

- 의존성 주입 패턴을 따르지 않는 경우 (**의존성을 직접 생성**하는 경우) -> 추상화의 이점 사라짐      
  - 객체가 **강하게 결합**
  - 의존성 **유연하게 변경 불가** 
  - (위 프로젝트의 경우) 응용 계층에서 인프라스트럭처 계층으로 다시 **의존 생김**.   


- 의존성 주입의 장점   
  - 객체 간 **결합도 감소** (추상화에 의존하여 객체 간 의존도 적음)
  - **유연성** (실행시점에 의존성 변경 가능)
  - **확장성** (새로운 구현체가 추가되어도 수정 필요없음) 
  - 테스트 용이성 (목 객체로 외부 의존성 없이 단위 테스트 수행 가능)

**✔ 의존성 역전 원칙 (DIP-Dependency Inversion Principle)**  
고수준 컴포넌트가 저수준 컴포넌트에 의존하면 안됨 -> 둘다 **추상화에 의존**해야함

>+고수준/저수준  
**고수준** 예시 -> 비즈니스 로직 또는 전체적인 흐름을 담당.   ex) 응용 계층   
**저수준** 예시 -> 구체적인 구현 및 수행. ex) 데이터베이스 담당하는 리포지토리   
(하지만 고수준/저수준은 상대적인 기준이기에 두 대상을 비교할 경우 **도메인과 가까울수록 고수준**, **외부와 가까울수록 저수준**으로 나눠야함)

- 의존성 방향
  - 기존의 방향: 서비스 계층(고수준)이 인프라스트럭처 계층(저수준)에 의존 
  - 변경된 방향: **인터페이스(추상적 존재)로 의존성 방향**이 모임. (저수준이 고수준에 의존하는 방향으로 **역전**됨) 


-> 즉, **의존성 역전 원칙**을 구현하기 위해 **추상화**를 사용하여 구체적인 구현이 아닌 인터페이스에 의존하도록 설계하고, **의존성 주입**을 통해 해당 인터페이스의 구현체를 외부에서 주입받았다. 
          
